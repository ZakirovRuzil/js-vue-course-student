## JavaScript 101

Как говорит Википедия, **`JavaScript` — мультипарадигменный язык программирования.
Поддерживает объектно-ориентированный, императивный и функциональный стили. Является
реализацией
спецификации [ECMAScript](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/)
.**

Первая полноценная версия языка появилась в августе 1996 и довольно быстро обрела
популярность. Причиной тому стал знакомый многим (похожий на `Java`) синтаксис, а также
тот факт, что язык был довольно просто для изучения. Изначально `JavaScript`
разрабатывался как "легкий" скриптовый язык для создания простой динамики в
веб-интерфейсах (сайты второй половины 90-х были в основном статичны), однако с тех пор
интернет-страницы сильно видоизменились - теперь во `frontend`-части приложений
присутствует много динамики и общая сложность интерфейсов выросла многократно.
Сам `JavaScript` тоже сильно изменился, но основные архитектурные черты изменений не
претерпели:

- **динамическая типизация**
- **слабая типизация**
- **автоматическое управление памятью**
- **прототипное программирование**
- **функции как объекты первого класса**

Так почему же `JavaScript` так популярен?

- Полная интеграция с `HTML/CSS`;
- Простые вещи делаются просто (функциональный подход);
- Он просто классный;
- Поддерживается всеми основными браузерами и включён по умолчанию;
- Прост для понимания. Имеет низкий порог входа;
- А еще на нем можно писать серверную часть приложений.

Большие приложения на данный момент не пишутся на "чистом" `JS` в силу некоторых причин.
Для серьезных разработок используются фреймворки, с одним из которых мы познакомимся во
второй половине курса.

***

### Где я могу запустить свой код на JS?

Работать с `JS`-кодом можно в большом количестве мест, например:

- IDE: <br>
    * **[VS Code](https://code.visualstudio.com/)**
    * **[WebStorm](https://www.jetbrains.com/ru-ru/webstorm/)** (PhpStorm)
    * etc.

- инструменты разработчика (`DevTools`)
- Редакторы кода в интернете:
    * **[Playcode](https://playcode.io/online-javascript-editor)**
    * **[Codepen](https://codepen.io/pen/)**
    * **[Replit](https://replit.com/languages/javascript)**

***

### Проверка стиля написания кода на JS

Для проверки стиля написания кода в `JS` чаще всего используется
библиотека **[Eslint](https://eslint.org/)**
При работе в `IDE` можно пользоваться встроенными возможностями редактора

***

### Спецификация ECMAScript

На данный момент актуальной спецификацией языка является `ES14` (`ECMAScript2023`). Однако
основным рубежом перехода от "старого" стиля к "новому" является смена спецификации `ES5`
на `ES6`, так как именно в этот момент в языке произошла масса изменений, повлиявших на
общую работу с `JS`. Более подробно с этими изменениями мы познакомимся по ходу данного
курса.

Основная суть смены заключается в том, что далеко не все браузеры могут работать с
новейшими синтаксическими конструкциями языка, поэтому знание этих различий очень важно в
процессе реальной разработки приложений. Конечно, есть способы сделать из `ES5`
кода `ES6+`, однако далеко не везде это делается и далеко не всегда особенности языка это
позволяют. В данном курсе мы будем работать с новейшим синтаксисом, однако забывать о
существовании "старого" тоже не стоит.

***

### Базовый синтаксис JavaScript

### Hello World! на JS

Первое, что необходимо написать на любом языке программирования, это
программа `hello world`. Для этого необходимо перейти в инструменты разработчика в
браузере, перейти во вкладку `console` и написать в ней следующее:

```
alert('Hello world!');
```

После чего нажать `Enter`. Перед нами появляется служебное окно с текстом `Hello world!`.
Ура, начало положено!

В консоли же текст можно вынести с помощью встроенного браузерного метода `console.log`:

```
console.log('Hello world!');
```

Для написания кода на `JS` подойдут файлы с многими расширениями, однако самый главный из
них - `.js`

### Типы данных в JS

В `JavaScript` существуют следующие типы данных:

`7` типов являются примитивными:

1. `undefined` - неопределенные значения (само значение отсутствует);
2. `boolean` - `true/false`;
3. `number` - любые числа: целые/дробные; <br>
   целые значения ограничены диапазоном `-2^53 + 1` ... `2^53 - 1`;
4. `string` - строки любой длины;
5. `bigint` - целые числа меньше `-2^53 + 1` и больше `+2^53 + 1`;
6. `symbol` - символьный тип, определен для создания уникальных идентификаторов;
7. `null` - специальный примитивный тип - неизвестные значения (само значение есть, но
   оно "пустое");

Особняком стоит простая структура данных - объект:

8. `object` - структура для хранения данных типа "ключ-значение". Данная структура также
   используется в качестве основы для создания других, более сложных типов структур
   в `JS`: так называемых "объектных" типов, таких как:

- Объекты `Object`
- Массивы `Array`
- Даты `Date`
- Регулярные выражения `RegExp`
- Коллекции `Map` и `Set`
- Ошибки `Error`

Есть два основных отличия "простых" и "сложных" типов:

1. "Простые" типы имеют свойство иммутабельности, то есть значения не могут быть изменены.
   Например, если мы создадим строку и попытаемся ее изменить, оригинальное значение
   останется без изменения:

```
const text = "itis";
text[2] = "a"; // текущее значение "text" все еще равно "itis"
```

Попытка изменить содержимое объекта, наоборот, увенчается успехом:

```
const information = {
    name: "Evan",
    surname: "You"
}

information.name = "Michael";

Объект information теперь имеет следующее содержание:
{
    name: "Michael",
    surname: "You"
}
```

Более подробно об объектах будет рассказано на второй занятии.

2. "Сложные" типы передаются по ссылке (более подробно на следующих занятиях).

#### Оператор typeof

Для определения типа данных используется оператор `typeof`:

```
typeof 42;              // "number"
typeof NaN;             // "number" - "Not A Number" - это тоже число
typeof 42n;             // "bigint"
typeof "itis";          // "string"
typeof true;            // "boolean"
typeof null;            // "object" - считается ошибкой языка, оставленной для обратной совместимости
typeof undefined;       // "undefined"
typeof Symbol("name");  // "symbol"
typeof {};              // "object"
typeof console.log;     // "function" - относится к объектому типу
```

Здесь же стоит уточнить, что такой способ определения не подходит для определения
сущностей объектных типов (все они будут иметь тип `object`), поэтому, например, для "
проверки на массив" используется метод `Array.isArray()`;

***

### Объектные типы данных в JS

Каждый элемент объектного типа имеет массу опций (в отличие от примитивных типов), доступ
к которым можно получить через точку:

```
const names = [ 'Justine' ];    // массив - будет подробно изучен на втором занятии
console.log(names.length);      // 1 - "length" - метод для определения длины массива 
```

Более того у примитивных типов тоже есть свои объектные аналоги. Если, например, создать
число через специальный конструктор `new`, это число будет иметь не примитивный
тип `number`, а объектный тип `object`:

```
const num = 42;                 // создаем простую строку
const newNum = new Number(42);  // создаем "объектную" строку

console.log(typeof num);        // 'number'
console.log(typeof newNum);     // 'object'
```

Создавать примитивные типы через конструкторы почти всегда бессмысленно, однако язык
все-таки оставляет нам такую возможность.

#### Упаковка данных

Рассмотрим следующий код:

```
const name = "Alex";
const nameLength = name.length; // 4
```

Итак, мы определили переменную с примитивным строковым значением, а потом использовали
метод у этого примитивного значения? Выше мы говорили о том, что у примитивных типов нет
методов. Так в чем же дело? <br>
А дело в том, что в момент обращения к методу `length` `JS` неявно "упаковывает" наше
примитивное значение в объектный тип данных `String`, у которого уже имеется масса
методов. После выполнения метода происходит обратная распаковка и в переменной `name`
снова лежит "примитивная" строка.

### Объявление переменных

#### Синтаксис ES5

В спецификации `ES5` переменные объявлялись единообразно, через ключевое слово `var`:

```
var name;   // объявили в коде переменную с именем `name` 
```

##### Область видимости

Область видимости определяет, где в коде программы будут доступны переменные и функции. В
`JavaScript` есть два типа области видимости - **лексическая** и **глобальная**

- **Лексическое** окружение создается каждый раз при вызове функции
- **Глобальное** окружение создается один раз и используется многократно

Есть и другое деление по типам областей видимости - **функциональная** и **блочная**. <br>
У `var` **функциональная** область видимости. Это значит, что переменная будет доступна в
любой точке функции, в которой она была определена:

```
function logDate() {
    for (var i = 0; i < 10; i++) {
        var text = 'i = ' + i;
    }
    console.log(text);  // `i = 9`
}
```

Также переменная доступна до ее объявления за счет ее "всплытия" в момент инициализации
кода. То есть:

```
function logDate() {
    // `undefined`, так как изначально здесь переменная уже определена,
    // но еще не имеет какого-либо значения, поэтому ее значение "не определено"
    console.log(text);
    for (var i = 0; i < 10; i++) {
        var text = 'i = ' + i;
    }
}
```

#### Синтаксис ES6+

В спецификации `ES6+` переменные можно объявить двумя способами:

- `let`

`Let` очень похож на `var`, но он имеет **блочную** область видимости, то есть переменная
будет доступна в пределах блока кода (в скобках `{}`), где она была объявлена:

```
function logDate() {
    for (let i = 0; i < 10; i++) {
        let text = 'i = ' + i;
    }
    console.log(text);  // `ReferenceError: text is not defined`
}
```

К тому же ошибка `ReferenceError` будет выкинута, если попытаться обратиться к переменной
до строки ее объявления. **Важно отметить**, что переменная "всплывает" аналогично `var`,
однако теперь она недоступна до инициализации (строки `let name`)

```
function logDate() {
    console.log(name);    // `ReferenceError: Cannot access 'name' before initialization`
    let name = 'Justine';
}
```

Таким образом, переменные, объявленные с помощью `var` и `let`, всплывают вверх при первом
проходе компилятора. Отличие заключается в том, что до инициализации переменной `var` мы
можем обратиться к ней, а в случае использования `let` - нет, будет выкинута
ошибка `ReferenceError`. Более того, `var` обладает функциональной областью видимости,
а `let` - блочной

- `const` - определение константных переменных в коде. Данные переменные имеют ту же
  область видимости, что и `let`, и тоже не будут доступны до инициализации. Отличие
  от `let` в том, что переменные, созданные с помощью `const` нельзя переопределять:

```
const name = 'Justine';
let surname = 'Henin';

name = 'Maria';         // TypeError: Assignment to constant variable.
surname = 'Sharapova';  // корректно обновится
```

При этом части переменной `const` все равно можно менять:

```
const letters = ['a', 'b', 'c'];
letters[3] = 'e';
console.log(letters);    // ['a', 'b', 'c', 'e']
```

Связано это с тем, что мы изменяем только "внутренности" элемента, а не заменяем сам
элемент на другой.

***

### Слабая динамическая типизация языка. Что такое явное и неявное сравнения

`JavaScript` обладает слабой динамической типизацией.

Термин **"динамическая типизация"** означает, что тип переменной определяется не в момент
определения самой переменной, а в момент присваивания ей значения:

```
let name;           // тип еще не присвоен, на данный момент `undefined`
name = 'Justine';   // а вот переменной `name` присваивается тип `string`; 
```

Это так же значит, что тип данных конкретной переменной может меняться:

```
let name = 'Justine';   // 'string'
name = 42;              // 'number'
name = true;            // 'boolean'
```

Термин **"слабая типизация"** означает, что в языке программирования разрешено выполнение
с любыми типами данных, которые будут неявно преобразовываться в другие типы. Рассмотрим
пример:

```
const sum = 4 + '2';    // равно '42' (type 'string')
const sum = '4' + 2;    // также равно '42' (type 'string')
```

В данном случае `JS`, несмотря на то, что мы пытаемся сложить число со строкой, не
выбрасывает ошибку, а пытается "распознать" наш замысел и, неявно преобразовывая число в
строку, склеивает нам в итоге две строки.

С неявным преобразованием в `JS` существует множество шуток. Вот одна из них:

```
const text = ('b' + 'a' + + 'a' + 'a').toLowerCase();
console.log(text);  // Вывод: 'banana'
```

Со слабой типизацией также связано и сравнение значений в `JS`: <br>

- Строгое сравнение

```
console.log(4 === 2);           // false
console.log(false === false);   // true
console.log({} === {});         // false - будет объяснено на втором занятии
console.log(42 === '42');       // false
```

- Нестрогое сравнение

```
console.log(4 == 2);            // false
console.log(1 == true);         // true - неявное преобразование
console.log(0 == false);        // true - неявное преобразование
console.log({} == {});          // false - будет объяснено на втором занятии
console.log(42 == '42');        // true - неявное преобразование
```

***

### Арифметические операции

- `+` - сложение; <br>

Краткий вариант сложения:

```
i = i + 1;
// То же самое, что и:
i += 1;
```

- `-` - вычитание; <br>

Краткий вариант вычитания:

```
i = i - 1;
// То же самое, что и:
i -= 1;
```

- `!` - отрицание:

```
console.log(!true);     // false
console.log(!!1);       // true
console.log(!null);     // true
const text = '';
console.log(!text);     // true
```

- `*` - умножение;
- `/` - деление;
- `**` - возведение в степень;
- `%` - остаток от деления:

```
const rest = 9 % 2;
console.log(rest);      // 1;
```

***

### Условные, логические операторы

- `if/else/else if`:

```
if (number > 10) {
    console.log('Число больше десяти');
} else if (number < 5) {
    console.log('Число меньше пяти');
} else {
    console.log('Ну и зачем здесь эти числа вообще...');
}
```

- оператор `&&` - `"И"`

```
if (number > 10 && number < 5) {
    console.log('Число больше десяти И меньше пяти');
}
```

- оператор `||` - `"Или"`

```
if (number > 10 || number < 5) {
    console.log('Число больше десяти ИЛИ меньше пяти');
}
```

- `switch/case`

```
const number = 42;

switch (number) {
    case 35:
        console.log('Это не 42, парень..');
        break;
    case 52:
        console.log('Это вообще ни разу не 42...');
        break;
    case 42:
        console.log('Ну наконец-то нормальное число...');
        break;
    default:
        console.log('Неизвестное число, дружище');
}
```

***

### Циклы

- `for`

```
for (let i = 10; i < 42; i += 1) {
    console.log('i = ' + i);
    if (i === 15) continue;     // переход к следующей итерации цикла
    if (i === 20) break;        // прерывание цикла
}
```

- `for of` - на следующем занятии
- `for in` - на следующем занятии
- `while`

```
let i = 30;
while (i < 42) {
    console.log('i = ' + i);
    i = i + 1;
}
```

- `do while`

```
let i = 30;
do {
    console.log('i = ' + i);
    i = i + 1;
} while (i < 42);
```

***

### Тернарный оператор

```
const isEven = (num) => num % 2 === 0;
const result = isEven(42) ? 'Да, четное' : 'Число нечетное';
```

***

### Объект `Math` и его методы

Для работы со сложными арифметическими операциями в `JS` есть глобально доступный
объект `Math`, предлагающий к использованию массу методов. Вот некоторые из них:

```
console.log(Math.E);            // 2.718281828459045
console.log(Math.PI);           // 3.141592653589793
console.log(Math.abs(-42));     // 42
console.log(Math.random());     // 0.19788252255701 - произвольное число от 0 до 1
// etc
```

***

### Взаимодействие с пользователем

- `alert` - выводит заданный текст пользователю
- `prompt` - запрашивает информацию у пользователя
- `confirm` - запрашивает у пользователя подтверждение

```
const currentPassword = '42';
const password = prompt('Скажи пароль!');
if (currentPassword === password) {
    alert('Ну ладно, заходи...');
} else {
    const hasDrinks = confirm('А напитки ты принес?');
    if (hasDrinks) {
        alert('Ну ладно, заходи...');
    } else {
        alert('Не тот пароль!');
    }
}
```

**PS**

Для выполнения задач Вам придется работать с функциями. Подробно о них будет рассказано в
следующем занятии, а сейчас достаточно разобраться с тем, как данные в функцию попадают и
как их из нее получить:

Разберем функцию в одной из задач:

```
// - changeCase - имя функции
// - (str) - аргументы функуии - данные, которые мы "прокидываем" в функцию
// - {} - тело функции - здесь нужно написать свой код
// - return str - возврат значений из функции

// Данный пример надуманный, но основные составляющие именно такие
 
const changeCase = (str) => {
    return str + str;
};
```

Чтобы использовать функцию, ее необходимо вызвать:

```
const text = 'example';
const result = changeCase(text);
console.log(result); // 'exampleexample'
```

После получения данных из функции мы можем дальше производить с ними какие-либо
манипуляции.