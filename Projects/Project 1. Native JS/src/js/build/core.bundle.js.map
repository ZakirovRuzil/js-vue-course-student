{"version":3,"file":"core.bundle.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://project-1-native-js/./src/js/const/index.js","webpack://project-1-native-js/./src/js/helpers/index.js","webpack://project-1-native-js/./src/js/init/index.js","webpack://project-1-native-js/./src/js/state/index.js","webpack://project-1-native-js/./src/js/watchers/index.js","webpack://project-1-native-js/../../node_modules/melanke-watchjs/src/watch.js","webpack://project-1-native-js/webpack/bootstrap","webpack://project-1-native-js/webpack/runtime/compat get default export","webpack://project-1-native-js/webpack/runtime/define property getters","webpack://project-1-native-js/webpack/runtime/hasOwnProperty shorthand","webpack://project-1-native-js/webpack/runtime/make namespace object","webpack://project-1-native-js/./src/index.js"],"sourcesContent":["export const MODALS_TYPES = {\n  NONE: 'none',\n  ANIME: 'anime',\n  ART_AND_DESIGN: 'art-and-design',\n  CALENDAR: 'calendar'\n};\nexport const BUTTONS = [{\n  text: 'ANIME',\n  type: MODALS_TYPES.ANIME\n}, {\n  text: 'ART AND DESIGN',\n  type: MODALS_TYPES.ART_AND_DESIGN\n}, {\n  text: 'CALENDAR',\n  type: MODALS_TYPES.CALENDAR\n}];\nexport const MODALS = [{\n  text: 'Later here will be an anime',\n  type: MODALS_TYPES.ANIME\n}, {\n  text: 'Later here will be a info about Art and Design',\n  type: MODALS_TYPES.ART_AND_DESIGN\n}, {\n  text: 'Later here will be a calendar',\n  type: MODALS_TYPES.CALENDAR\n}];","import state from \"../state/index\";\nimport { MODALS, MODALS_TYPES } from \"../const\";\nexport const closeModal = () => {\n  state.openedModal = MODALS_TYPES.NONE;\n};\nexport const findOpenedModalIndex = () => {\n  return MODALS.findIndex(item => item.type === state.openedModal);\n};","import { BUTTONS, MODALS } from \"../const\";\nimport state from \"../state\";\nimport { closeModal, findOpenedModalIndex } from \"../helpers\";\nexport const renderButtons = () => {\n  const buttonsContainer = document.querySelector('.buttons-container');\n  BUTTONS.forEach(item => {\n    const button = document.createElement('button');\n    button.textContent = item.text;\n    button.dataset.type = item.type;\n    button.addEventListener('click', event => {\n      state.openedModal = item.type;\n      event.stopPropagation();\n    });\n    buttonsContainer.append(button);\n  });\n};\nexport const renderModalWindows = () => {\n  const app = document.querySelector('.app');\n  MODALS.forEach(item => {\n    const prevButton = document.createElement('a');\n    prevButton.className = 'control-button';\n    prevButton.href = '#';\n    prevButton.textContent = 'Close';\n    const nextButton = document.createElement('a');\n    prevButton.className = 'control-button';\n    prevButton.href = '#';\n    prevButton.textContent = 'Next';\n    const closeButton = document.createElement('a');\n    prevButton.className = 'control-button';\n    prevButton.href = '#';\n    prevButton.textContent = 'Previous';\n    prevButton.addEventListener('click', event => {\n      const currentOpenedModalIndex = findOpenedModalIndex();\n\n      if (currentOpenedModalIndex === 0) {\n        state.openedModal = MODALS[MODALS.length - 1].type;\n      } else {\n        state.openedModalType = MODALS[currentOpenedModalIndex - 1].type;\n      }\n\n      event.stopPropagation();\n    });\n    nextButton.addEventListener('click', event => {\n      const currentOpenedModalIndex = findOpenedModalIndex();\n\n      if (currentOpenedModalIndex === MODALS.length - 1) {\n        state.openedModalType = MODALS[0].type;\n      } else {\n        state.openedModalType = MODALS[currentOpenedModalIndex + 1].type;\n      }\n\n      event.stopPropagation();\n    });\n    closeButton.addEventListener('click', event => {\n      closeModal();\n      event.stopPropagation();\n    });\n    const modalWindow = document.createElement('div');\n    modalWindow.className = 'modal-window';\n    modalWindow.dataset.type = item.type;\n    modalWindow.textContent = item.text;\n    modalWindow.append(prevButton);\n    modalWindow.append(nextButton);\n    modalWindow.append(closeButton);\n    app.append(modalWindow);\n  });\n};","import { MODALS, MODALS_TYPES } from \"../const/index\";\nexport default {\n  openedModal: MODALS_TYPES.NONE\n};","import WatchJS from 'melanke-watchjs';\nimport state from '../state';\nexport const watch = WatchJS;\nwatch(state, 'openedModal', () => {\n  const modalWindows = document.querySelectorAll('.modal-window');\n  modalWindows.forEach(item => {\n    if (state.openedModal === item[data - type]) {\n      item.style.display = 'block';\n    } else {\n      item.style.display = 'none';\n    }\n  });\n});","/**\r\n * DEVELOPED BY\r\n * GIL LOPES BUENO\r\n * gilbueno.mail@gmail.com\r\n *\r\n * WORKS WITH:\r\n * IE8*, IE 9+, FF 4+, SF 5+, WebKit, CH 7+, OP 12+, BESEN, Rhino 1.7+\r\n * For IE8 (and other legacy browsers) WatchJS will use dirty checking  \r\n *\r\n * FORK:\r\n * https://github.com/melanke/Watch.JS\r\n *\r\n * LICENSE: MIT\r\n */\n\"use strict\";\n\n(function (factory) {\n  if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else {\n    // Browser globals\n    window.WatchJS = factory();\n    window.watch = window.WatchJS.watch;\n    window.unwatch = window.WatchJS.unwatch;\n    window.callWatchers = window.WatchJS.callWatchers;\n  }\n})(function () {\n  var WatchJS = {\n    noMore: false,\n    // use WatchJS.suspend(obj) instead\n    useDirtyCheck: false,\n    // use only dirty checking to track changes.\n    preserveExistingSetters: false\n  },\n      lengthsubjects = [];\n  var dirtyChecklist = [];\n  var pendingChanges = []; // used coalesce changes from defineProperty and __defineSetter__\n\n  var supportDefineProperty = false;\n\n  try {\n    supportDefineProperty = Object.defineProperty && Object.defineProperty({}, 'x', {});\n  } catch (ex) {\n    /* not supported */\n  }\n\n  var isFunction = function (functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\n  };\n\n  var isInt = function (x) {\n    return x % 1 === 0;\n  };\n\n  var isArray = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  var isObject = function (obj) {\n    return {}.toString.apply(obj) === '[object Object]';\n  };\n\n  var getObjDiff = function (a, b) {\n    var aplus = [],\n        bplus = [];\n\n    if (!(typeof a == \"string\") && !(typeof b == \"string\")) {\n      if (isArray(a) && b) {\n        for (var i = 0; i < a.length; i++) {\n          if (b[i] === undefined) aplus.push(i);\n        }\n      } else {\n        for (var i in a) {\n          if (a.hasOwnProperty(i)) {\n            if (b && !b.hasOwnProperty(i)) {\n              aplus.push(i);\n            }\n          }\n        }\n      }\n\n      if (isArray(b) && a) {\n        for (var j = 0; j < b.length; j++) {\n          if (a[j] === undefined) bplus.push(j);\n        }\n      } else {\n        for (var j in b) {\n          if (b.hasOwnProperty(j)) {\n            if (a && !a.hasOwnProperty(j)) {\n              bplus.push(j);\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      added: aplus,\n      removed: bplus\n    };\n  };\n\n  var clone = function (obj) {\n    if (null == obj || \"object\" != typeof obj) {\n      return obj;\n    }\n\n    var copy = obj.constructor();\n\n    for (var attr in obj) {\n      copy[attr] = obj[attr];\n    }\n\n    return copy;\n  };\n\n  var getExistingSetter = function (obj, propName) {\n    if (WatchJS.preserveExistingSetters) {\n      var existing = Object.getOwnPropertyDescriptor(obj, propName);\n      return existing.set;\n    }\n\n    return undefined;\n  };\n\n  var defineGetAndSet = function (obj, propName, getter, setter) {\n    try {\n      var existingSetter = getExistingSetter(obj, propName);\n      Object.defineProperty(obj, propName, {\n        get: getter,\n        set: function (value) {\n          setter.call(this, value, true); // coalesce changes\n\n          if (existingSetter) {\n            existingSetter(value);\n          }\n        },\n        enumerable: true,\n        configurable: true\n      });\n    } catch (e1) {\n      try {\n        Object.prototype.__defineGetter__.call(obj, propName, getter);\n\n        Object.prototype.__defineSetter__.call(obj, propName, function (value) {\n          setter.call(this, value, true); // coalesce changes\n        });\n      } catch (e2) {\n        observeDirtyChanges(obj, propName, setter); //throw new Error(\"watchJS error: browser not supported :/\")\n      }\n    }\n  };\n\n  var defineProp = function (obj, propName, value) {\n    try {\n      Object.defineProperty(obj, propName, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: value\n      });\n    } catch (error) {\n      obj[propName] = value;\n    }\n  };\n\n  var observeDirtyChanges = function (obj, propName, setter) {\n    dirtyChecklist[dirtyChecklist.length] = {\n      prop: propName,\n      object: obj,\n      orig: clone(obj[propName]),\n      callback: setter\n    };\n  };\n\n  var watch = function () {\n    if (isFunction(arguments[1])) {\n      watchAll.apply(this, arguments);\n    } else if (isArray(arguments[1])) {\n      watchMany.apply(this, arguments);\n    } else {\n      watchOne.apply(this, arguments);\n    }\n  };\n\n  var watchAll = function (obj, watcher, level, addNRemove) {\n    if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n      //accepts only objects and array (not string)\n      return;\n    }\n\n    if (isArray(obj)) {\n      defineWatcher(obj, \"__watchall__\", watcher, level); // watch all changes on the array\n\n      if (level === undefined || level > 0) {\n        for (var prop = 0; prop < obj.length; prop++) {\n          // watch objects in array\n          watchAll(obj[prop], watcher, level, addNRemove);\n        }\n      }\n    } else {\n      var prop,\n          props = [];\n\n      for (prop in obj) {\n        //for each attribute if obj is an object\n        if (prop == \"$val\" || !supportDefineProperty && prop === 'watchers') {\n          continue;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n          props.push(prop); //put in the props\n        }\n      }\n\n      watchMany(obj, props, watcher, level, addNRemove); //watch all items of the props\n    }\n\n    if (addNRemove) {\n      pushToLengthSubjects(obj, \"$$watchlengthsubjectroot\", watcher, level);\n    }\n  };\n\n  var watchMany = function (obj, props, watcher, level, addNRemove) {\n    if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n      //accepts only objects and array (not string)\n      return;\n    }\n\n    for (var i = 0; i < props.length; i++) {\n      //watch each property\n      var prop = props[i];\n      watchOne(obj, prop, watcher, level, addNRemove);\n    }\n  };\n\n  var watchOne = function (obj, prop, watcher, level, addNRemove) {\n    if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n      //accepts only objects and array (not string)\n      return;\n    }\n\n    if (isFunction(obj[prop])) {\n      //dont watch if it is a function\n      return;\n    }\n\n    if (obj[prop] != null && (level === undefined || level > 0)) {\n      watchAll(obj[prop], watcher, level !== undefined ? level - 1 : level); //recursively watch all attributes of this\n    }\n\n    defineWatcher(obj, prop, watcher, level);\n\n    if (addNRemove && (level === undefined || level > 0)) {\n      pushToLengthSubjects(obj, prop, watcher, level);\n    }\n  };\n\n  var unwatch = function () {\n    if (isFunction(arguments[1])) {\n      unwatchAll.apply(this, arguments);\n    } else if (isArray(arguments[1])) {\n      unwatchMany.apply(this, arguments);\n    } else {\n      unwatchOne.apply(this, arguments);\n    }\n  };\n\n  var unwatchAll = function (obj, watcher) {\n    if (obj instanceof String || !(obj instanceof Object) && !isArray(obj)) {\n      //accepts only objects and array (not string)\n      return;\n    }\n\n    if (isArray(obj)) {\n      var props = ['__watchall__'];\n\n      for (var prop = 0; prop < obj.length; prop++) {\n        //for each item if obj is an array\n        props.push(prop); //put in the props\n      }\n\n      unwatchMany(obj, props, watcher); //watch all itens of the props\n    } else {\n      var unwatchPropsInObject = function (obj2) {\n        var props = [];\n\n        for (var prop2 in obj2) {\n          //for each attribute if obj is an object\n          if (obj2.hasOwnProperty(prop2)) {\n            if (obj2[prop2] instanceof Object) {\n              unwatchPropsInObject(obj2[prop2]); //recurs into object props\n            } else {\n              props.push(prop2); //put in the props\n            }\n          }\n        }\n\n        unwatchMany(obj2, props, watcher); //unwatch all of the props\n      };\n\n      unwatchPropsInObject(obj);\n    }\n  };\n\n  var unwatchMany = function (obj, props, watcher) {\n    for (var prop2 in props) {\n      //watch each attribute of \"props\" if is an object\n      if (props.hasOwnProperty(prop2)) {\n        unwatchOne(obj, props[prop2], watcher);\n      }\n    }\n  };\n\n  var timeouts = [],\n      timerID = null;\n\n  function clearTimerID() {\n    timerID = null;\n\n    for (var i = 0; i < timeouts.length; i++) {\n      timeouts[i]();\n    }\n\n    timeouts.length = 0;\n  }\n\n  var getTimerID = function () {\n    if (!timerID) {\n      timerID = setTimeout(clearTimerID);\n    }\n\n    return timerID;\n  };\n\n  var registerTimeout = function (fn) {\n    // register function to be called on timeout\n    if (timerID == null) getTimerID();\n    timeouts[timeouts.length] = fn;\n  }; // Track changes made to an array, object or an object's property \n  // and invoke callback with a single change object containing type, value, oldvalue and array splices\n  // Syntax: \n  //      trackChange(obj, callback, recursive, addNRemove)\n  //      trackChange(obj, prop, callback, recursive, addNRemove)\n\n\n  var trackChange = function () {\n    var fn = isFunction(arguments[2]) ? trackProperty : trackObject;\n    fn.apply(this, arguments);\n  }; // track changes made to an object and invoke callback with a single change object containing type, value and array splices\n\n\n  var trackObject = function (obj, callback, recursive, addNRemove) {\n    var change = null,\n        lastTimerID = -1;\n    var isArr = isArray(obj);\n\n    var level,\n        fn = function (prop, action, newValue, oldValue) {\n      var timerID = getTimerID();\n\n      if (lastTimerID !== timerID) {\n        // check if timer has changed since last update\n        lastTimerID = timerID;\n        change = {\n          type: 'update'\n        };\n        change['value'] = obj;\n        change['splices'] = null;\n        registerTimeout(function () {\n          callback.call(this, change);\n          change = null;\n        });\n      } // create splices for array changes\n\n\n      if (isArr && obj === this && change !== null) {\n        if (action === 'pop' || action === 'shift') {\n          newValue = [];\n          oldValue = [oldValue];\n        } else if (action === 'push' || action === 'unshift') {\n          newValue = [newValue];\n          oldValue = [];\n        } else if (action !== 'splice') {\n          return; // return here - for reverse and sort operations we don't need to return splices. a simple update will do\n        }\n\n        if (!change.splices) change.splices = [];\n        change.splices[change.splices.length] = {\n          index: prop,\n          deleteCount: oldValue ? oldValue.length : 0,\n          addedCount: newValue ? newValue.length : 0,\n          added: newValue,\n          deleted: oldValue\n        };\n      }\n    };\n\n    level = recursive == true ? undefined : 0;\n    watchAll(obj, fn, level, addNRemove);\n  }; // track changes made to the property of an object and invoke callback with a single change object containing type, value, oldvalue and splices\n\n\n  var trackProperty = function (obj, prop, callback, recursive, addNRemove) {\n    if (obj && prop) {\n      watchOne(obj, prop, function (prop, action, newvalue, oldvalue) {\n        var change = {\n          type: 'update'\n        };\n        change['value'] = newvalue;\n        change['oldvalue'] = oldvalue;\n\n        if (recursive && isObject(newvalue) || isArray(newvalue)) {\n          trackObject(newvalue, callback, recursive, addNRemove);\n        }\n\n        callback.call(this, change);\n      }, 0);\n\n      if (recursive && isObject(obj[prop]) || isArray(obj[prop])) {\n        trackObject(obj[prop], callback, recursive, addNRemove);\n      }\n    }\n  };\n\n  var defineWatcher = function (obj, prop, watcher, level) {\n    var newWatcher = false;\n    var isArr = isArray(obj);\n\n    if (!obj.watchers) {\n      defineProp(obj, \"watchers\", {});\n\n      if (isArr) {\n        // watch array functions\n        watchFunctions(obj, function (index, action, newValue, oldValue) {\n          addPendingChange(obj, index, action, newValue, oldValue);\n\n          if (level !== 0 && newValue && (isObject(newValue) || isArray(newValue))) {\n            var i,\n                n,\n                ln,\n                wAll,\n                watchList = obj.watchers[prop];\n\n            if (wAll = obj.watchers['__watchall__']) {\n              watchList = watchList ? watchList.concat(wAll) : wAll;\n            }\n\n            ln = watchList ? watchList.length : 0;\n\n            for (i = 0; i < ln; i++) {\n              if (action !== 'splice') {\n                watchAll(newValue, watchList[i], level === undefined ? level : level - 1);\n              } else {\n                // watch spliced values\n                for (n = 0; n < newValue.length; n++) {\n                  watchAll(newValue[n], watchList[i], level === undefined ? level : level - 1);\n                }\n              }\n            }\n          }\n        });\n      }\n    }\n\n    if (!obj.watchers[prop]) {\n      obj.watchers[prop] = [];\n      if (!isArr) newWatcher = true;\n    }\n\n    for (var i = 0; i < obj.watchers[prop].length; i++) {\n      if (obj.watchers[prop][i] === watcher) {\n        return;\n      }\n    }\n\n    obj.watchers[prop].push(watcher); //add the new watcher to the watchers array\n\n    if (newWatcher) {\n      var val = obj[prop];\n\n      var getter = function () {\n        return val;\n      };\n\n      var setter = function (newval, delayWatcher) {\n        var oldval = val;\n        val = newval;\n\n        if (level !== 0 && obj[prop] && (isObject(obj[prop]) || isArray(obj[prop])) && !obj[prop].watchers) {\n          // watch sub properties\n          var i,\n              ln = obj.watchers[prop].length;\n\n          for (i = 0; i < ln; i++) {\n            watchAll(obj[prop], obj.watchers[prop][i], level === undefined ? level : level - 1);\n          }\n        } //watchFunctions(obj, prop);\n\n\n        if (isSuspended(obj, prop)) {\n          resume(obj, prop);\n          return;\n        }\n\n        if (!WatchJS.noMore) {\n          // this does not work with Object.observe\n          //if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\n          if (obj[prop] instanceof Date && oldval && newval) {\n            oldval = oldval.valueOf();\n            newval = newval.valueOf();\n          }\n\n          if (oldval !== newval) {\n            if (!delayWatcher) {\n              callWatchers(obj, prop, \"set\", newval, oldval);\n            } else {\n              addPendingChange(obj, prop, \"set\", newval, oldval);\n            }\n\n            WatchJS.noMore = false;\n          }\n        }\n      };\n\n      if (WatchJS.useDirtyCheck) {\n        observeDirtyChanges(obj, prop, setter);\n      } else {\n        defineGetAndSet(obj, prop, getter, setter);\n      }\n    }\n  };\n\n  var callWatchers = function (obj, prop, action, newval, oldval) {\n    if (prop !== undefined) {\n      var ln,\n          wl,\n          watchList = obj.watchers[prop];\n\n      if (wl = obj.watchers['__watchall__']) {\n        watchList = watchList ? watchList.concat(wl) : wl;\n      }\n\n      ln = watchList ? watchList.length : 0;\n\n      for (var wr = 0; wr < ln; wr++) {\n        watchList[wr].call(obj, prop, action, newval, oldval);\n      }\n    } else {\n      for (var prop in obj) {\n        //call all\n        if (obj.hasOwnProperty(prop)) {\n          callWatchers(obj, prop, action, newval, oldval);\n        }\n      }\n    }\n  };\n\n  var methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift', 'splice'];\n\n  var defineArrayMethodWatcher = function (obj, original, methodName, callback) {\n    defineProp(obj, methodName, function () {\n      var index = 0;\n      var i, newValue, oldValue, response; // get values before splicing array \n\n      if (methodName === 'splice') {\n        var start = arguments[0];\n        var end = start + arguments[1];\n        oldValue = obj.slice(start, end);\n        newValue = [];\n\n        for (i = 2; i < arguments.length; i++) {\n          newValue[i - 2] = arguments[i];\n        }\n\n        index = start;\n      } else {\n        newValue = arguments.length > 0 ? arguments[0] : undefined;\n      }\n\n      response = original.apply(obj, arguments);\n\n      if (methodName !== 'slice') {\n        if (methodName === 'pop') {\n          oldValue = response;\n          index = obj.length;\n        } else if (methodName === 'push') {\n          index = obj.length - 1;\n        } else if (methodName === 'shift') {\n          oldValue = response;\n        } else if (methodName !== 'unshift' && newValue === undefined) {\n          newValue = response;\n        }\n\n        callback.call(obj, index, methodName, newValue, oldValue);\n      }\n\n      return response;\n    });\n  };\n\n  var watchFunctions = function (obj, callback) {\n    if (!isFunction(callback) || !obj || obj instanceof String || !isArray(obj)) {\n      return;\n    }\n\n    for (var i = methodNames.length, methodName; i--;) {\n      methodName = methodNames[i];\n      defineArrayMethodWatcher(obj, obj[methodName], methodName, callback);\n    }\n  };\n\n  var unwatchOne = function (obj, prop, watcher) {\n    if (prop) {\n      if (obj.watchers && obj.watchers[prop]) {\n        if (watcher === undefined) {\n          delete obj.watchers[prop]; // remove all property watchers\n        } else {\n          for (var i = 0; i < obj.watchers[prop].length; i++) {\n            var w = obj.watchers[prop][i];\n\n            if (w == watcher) {\n              obj.watchers[prop].splice(i, 1);\n            }\n          }\n        }\n      }\n    } else {\n      delete obj.watchers;\n    }\n\n    removeFromLengthSubjects(obj, prop, watcher);\n    removeFromDirtyChecklist(obj, prop);\n  }; // suspend watchers until next update cycle\n\n\n  var suspend = function (obj, prop) {\n    if (obj.watchers) {\n      var name = '__wjs_suspend__' + (prop !== undefined ? prop : '');\n      obj.watchers[name] = true;\n    }\n  };\n\n  var isSuspended = function (obj, prop) {\n    return obj.watchers && (obj.watchers['__wjs_suspend__'] || obj.watchers['__wjs_suspend__' + prop]);\n  }; // resumes preivously suspended watchers\n\n\n  var resume = function (obj, prop) {\n    registerTimeout(function () {\n      delete obj.watchers['__wjs_suspend__'];\n      delete obj.watchers['__wjs_suspend__' + prop];\n    });\n  };\n\n  var pendingTimerID = null;\n\n  var addPendingChange = function (obj, prop, mode, newval, oldval) {\n    pendingChanges[pendingChanges.length] = {\n      obj: obj,\n      prop: prop,\n      mode: mode,\n      newval: newval,\n      oldval: oldval\n    };\n\n    if (pendingTimerID === null) {\n      pendingTimerID = setTimeout(applyPendingChanges);\n    }\n  };\n\n  var applyPendingChanges = function () {\n    // apply pending changes\n    var change = null;\n    pendingTimerID = null;\n\n    for (var i = 0; i < pendingChanges.length; i++) {\n      change = pendingChanges[i];\n      callWatchers(change.obj, change.prop, change.mode, change.newval, change.oldval);\n    }\n\n    if (change) {\n      pendingChanges = [];\n      change = null;\n    }\n  };\n\n  var loop = function () {\n    // check for new or deleted props\n    for (var i = 0; i < lengthsubjects.length; i++) {\n      var subj = lengthsubjects[i];\n\n      if (subj.prop === \"$$watchlengthsubjectroot\") {\n        var difference = getObjDiff(subj.obj, subj.actual);\n\n        if (difference.added.length || difference.removed.length) {\n          if (difference.added.length) {\n            watchMany(subj.obj, difference.added, subj.watcher, subj.level - 1, true);\n          }\n\n          subj.watcher.call(subj.obj, \"root\", \"differentattr\", difference, subj.actual);\n        }\n\n        subj.actual = clone(subj.obj);\n      } else {\n        var difference = getObjDiff(subj.obj[subj.prop], subj.actual);\n\n        if (difference.added.length || difference.removed.length) {\n          if (difference.added.length) {\n            for (var j = 0; j < subj.obj.watchers[subj.prop].length; j++) {\n              watchMany(subj.obj[subj.prop], difference.added, subj.obj.watchers[subj.prop][j], subj.level - 1, true);\n            }\n          }\n\n          callWatchers(subj.obj, subj.prop, \"differentattr\", difference, subj.actual);\n        }\n\n        subj.actual = clone(subj.obj[subj.prop]);\n      }\n    } // start dirty check\n\n\n    var n, value;\n\n    if (dirtyChecklist.length > 0) {\n      for (var i = 0; i < dirtyChecklist.length; i++) {\n        n = dirtyChecklist[i];\n        value = n.object[n.prop];\n\n        if (!compareValues(n.orig, value)) {\n          n.orig = clone(value);\n          n.callback(value);\n        }\n      }\n    }\n  };\n\n  var compareValues = function (a, b) {\n    var i,\n        state = true;\n\n    if (a !== b) {\n      if (isObject(a)) {\n        for (i in a) {\n          if (!supportDefineProperty && i === 'watchers') continue;\n\n          if (a[i] !== b[i]) {\n            state = false;\n            break;\n          }\n\n          ;\n        }\n      } else {\n        state = false;\n      }\n    }\n\n    return state;\n  };\n\n  var pushToLengthSubjects = function (obj, prop, watcher, level) {\n    var actual;\n\n    if (prop === \"$$watchlengthsubjectroot\") {\n      actual = clone(obj);\n    } else {\n      actual = clone(obj[prop]);\n    }\n\n    lengthsubjects.push({\n      obj: obj,\n      prop: prop,\n      actual: actual,\n      watcher: watcher,\n      level: level\n    });\n  };\n\n  var removeFromLengthSubjects = function (obj, prop, watcher) {\n    for (var i = 0; i < lengthsubjects.length; i++) {\n      var subj = lengthsubjects[i];\n\n      if (subj.obj == obj) {\n        if (!prop || subj.prop == prop) {\n          if (!watcher || subj.watcher == watcher) {\n            // if we splice off one item at position i\n            // we need to decrement i as the array is one item shorter\n            // so when we increment i in the loop statement we\n            // will land at the correct index.\n            // if it's not decremented, you won't delete all length subjects\n            lengthsubjects.splice(i--, 1);\n          }\n        }\n      }\n    }\n  };\n\n  var removeFromDirtyChecklist = function (obj, prop) {\n    var notInUse;\n\n    for (var i = 0; i < dirtyChecklist.length; i++) {\n      var n = dirtyChecklist[i];\n      var watchers = n.object.watchers;\n      notInUse = n.object == obj && (!prop || n.prop == prop) && watchers && (!prop || !watchers[prop] || watchers[prop].length == 0);\n\n      if (notInUse) {\n        // we use the same syntax as in removeFromLengthSubjects\n        dirtyChecklist.splice(i--, 1);\n      }\n    }\n  };\n\n  setInterval(loop, 50);\n  WatchJS.watch = watch;\n  WatchJS.unwatch = unwatch;\n  WatchJS.callWatchers = callWatchers;\n  WatchJS.suspend = suspend; // suspend watchers    \n\n  WatchJS.onChange = trackChange; // track changes made to object or  it's property and return a single change object\n\n  return WatchJS;\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { watch } from './js/watchers';\nimport { closeModal } from \"./js/helpers\";\nimport { renderButtons, renderModalWindows } from \"./js/init\";\ndocument.addEventListener('click', closeModal);\nrenderButtons();\nrenderModalWindows();"],"names":[],"sourceRoot":""}